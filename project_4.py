# -*- coding: utf-8 -*-
"""Project 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sazBsv5KB9-9YJVOZuNETp1-pLSwqV27
"""

import numpy as np
import matplotlib.pyplot as plt

#CONSTANTS
AG = 1.25
AS = .8

#OBJECTS
class simTime:
  def __init__(self, time, dt, tol, agrow, ashrink, dtmin, dtmax,
endTime, stepsSinceRejection, stepsRejected, stepsAccepted):
    self.time = time
    self.dt = dt
    self.tol = tol
    self.agrow = agrow
    self.ashrink = ashrink
    self.dtmin = dtmin
    self.dtmax = dtmax
    self.endTime = endTime
    self.stepsSinceRejection = stepsSinceRejection
    self.stepsRejected = stepsRejected
    self.stepsAccepted = stepsAccepted

#FUNCTIONS
def step1(Y, t, dt, f):
  W = Y + dt * f(t, Y)
  return W

def step2(Y, t, dt, f):
  Ydt = step1(Y,t,dt,f)
  Ydt2 = step1(Y,t,dt/2,f)
  Ydt2 = step1(Ydt2,t + dt/2,dt/2,f)
  ddY = Ydt2-Ydt
  W = Ydt2 + ddY
  return W

def step3(Y, t, dt, f):
  Ydt = step2(Y,t,dt,f)
  Ydt2 = step2(Y,t,dt/2,f)
  Ydt2 = step2(Ydt2,t + dt/2,dt/2,f)
  ddY = Ydt2-Ydt
  W = Ydt2 + (1/3)*ddY
  ei = np.linalg.norm(Ydt - Ydt2)
  return [W, ei]

def adjust_dt(sim, ei):

  #SHRINK OR GROW
  if ((sim.stepsSinceRejection >= 1) and (ei < sim.tol/4)):
    newdt = sim.agrow *sim.dt
    if(newdt <= sim.dtmax):
      sim.dt = newdt
  elif(ei > .75*sim.tol):
    newdt = sim.ashrink * sim.dt
    if(newdt >= sim.dtmin):
      sim.dt = newdt

def advance(sim, y, f, acc):

  #END AT END TIME
  if (sim.dt  + sim.time > sim.endTime):
    sim.dt = sim.endTime - sim.time

  #FIRST CALCULATION
  W = step3(y, sim.time, sim.dt, f)
  ei = W[1]
  testY = W[0]

  #END OF RECURSION
  if (sim.time + sim.dt == sim.endTime):
    acc.append([sim.time+sim.dt, testY])
    return [acc, sim.stepsAccepted, sim.stepsAccepted]

  #GOOD STEP / BAD STEP
  if(ei > sim.tol):
    #BAD STEP

    if (2 * sim.dtmin > sim.endTime - sim.time):
      #REJECTED
      sim.stepsSinceRejection = 0
      sim.stepsRejected +=1
      
      sim.dt = sim.dt/2
      adjust_dt(sim, ei)
      return advance(sim, y, f, acc)
    else:
      #HALVE DT
      newdt = sim.dt/2
      if (newdt >= sim.dtmin):
        #REJECTED
        sim.stepsSinceRejection = 0
        sim.stepsRejected +=1

        sim.dt = newdt
        adjust_dt(sim, ei)
        return advance(sim, y, f, acc)
      else:
        #NOT REJECTED
        sim.time +=sim.dt
        acc.append([sim.time, testY])
        sim.stepsSinceRejection +=1
        sim.stepsAccepted +=1
        adjust_dt(sim, ei)
        return advance(sim, testY, f, acc)
  else:
    #GOOD STEP
    #NOT REJECTED
    sim.time += sim.dt
    acc.append([sim.time, testY])
    adjust_dt(sim, ei)
    sim.stepsSinceRejection +=1
    sim.stepsAccepted +=1
    return advance(sim, testY, f, acc)

#TESTING

#f
m = 2
def func(t, y):
  return (m+1)*(t**m)

#Simulation
delt = .3
test = simTime(0, delt, .001, AG, AS, .05, .2, 2, 0, 0, 0)
output=advance(test, 0, func, [])

#TESTING

output = list(zip(*output[0]))
plt.scatter(output[0], output[1])

#TESTING
def metafunc(t, y, m):
  return (m+1)*(t**m)
for i in list(range(0, 5)):
  m = i
  def func(t, y):
    return metafunc(t, y, m)

  delt = .3
  test = simTime(0, delt, .001, AG, AS, .05, .2, 2, 0, 0, 0)
  output = advance(test, 0, func, [])
  output = list(zip(*(output[0])))
  print(output)

#RESULTS
def func(t, Y):
  u0, u1, u2, u3 = Y[0], Y[1], Y[2], Y[3]
  return np.array((u2, u3, -1 * u0 / (np.abs(u0**2 + u1**2)**1.5), -1 * u1 / (np.abs(u0**2 + u1**2)**1.5)))
delt = .1
test = simTime(0, delt, .001, AG, AS, .001, .2, 6 * np.pi / ((2 - .3 **2)**(1.5)), 0, 0, 0)
output=advance(test, (.5**(.5), (.5**(.5)), -.3 *(.5 **(.5)), .3 *(.5 **(.5))), func, [])
data = list(zip(*output[0]))
datap = list(zip(*data[1]))

length = len(output[0])
array = []
for i in range(length):
  array.append([255*(length- i)/(length),1*(length-i)/(length),255*(length-i)/(length)])
colors = array
plt.scatter(datap[0], datap[1], s = 1, c = (1/255)*np.array(colors))
plt.xlabel("x position")
plt.ylabel("y position")
plt.title("trajectory of orbit over two periods")
plt.figure()
plt.show()

